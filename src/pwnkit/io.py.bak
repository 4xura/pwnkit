from __future__ import annotations
from typing import Union, Optional
from dataclasses import dataclass
from pwn import tube, u64 
import os

__all__ = [
        "IoConfig",
        "IoAlias",
        "set_global_io", "s", "sa", "sl", "sla", "r", "ru", "uu64", "itoa",
        ]

chars = Union[str, bytes]

# Scaffold IO config for target binary
# ------------------------------------------------------------------------
@dataclass
class IoConfig:
    file_path: str 
    libc_path: Optional[str] = None
    host: Optional[str] = None
    port: Optional[int] = None

    def is_remote(self) -> bool:
        return self.host is not None and self.port is not None

    def init_io_cmd(self) -> str:
        """
        Return a Python expression string for pwntools I/O setup,
        to be inserted in a scaffold.
        """
        if self.is_remote():
            return f'remote({self.host!r}, {self.port})'
        if self.libc_path:
            libc_abs = os.path.abspath(self.libc_path)
            libdir   = os.path.dirname(libc_abs) or "."
            env_code = {"LD_PRELOAD": libc_abs, "LD_LIBRARY_PATH": libdir}
            return f'process({self.file_path!r}, env={env_code!r})'
        return f'process({self.file_path!r})'

# Instance-bound shortcut object (main choice)
# ------------------------------------------------------------------------
@dataclass
class IoAlias:
    """
    Wrap a pwntools tube and add short methods while forwarding everything else
    Usage:
        io = process("./vuln")
        io = IoAlias(io)
        io.s(b"AAAA"); io.sla(b"> ", b"1"); addr = io.uu64(leak)
    """
    _io: tube

    def __getattr__(self, name: str):
        return getattr(self._io, name)

    def s(self, data: bytes) -> None:
        self._io.send(data)

    def sa(self, delim: chars, data: bytes) -> None:
        self._io.sendafter(delim, data)

    def sl(self, data: chars) -> None:
        self._io.sendline(data)

    def sla(self, delim: chars, data: chars) -> None:
        self._io.sendlineafter(delim, data)

    def r(self, n: int = 4096) -> bytes:
        return self._io.recv(n)

    def ru(self, delim: chars, drop: bool = True) -> bytes:
        return self._io.recvuntil(delim, drop=drop)

    @staticmethod
    def uu64(data: bytes) -> int:
        return u64(data.ljust(8, b"\x00"))

# Global short aliases (optional)
# ------------------------------------------------------------------------
_global_io: tube | None = None
def set_global_io(io: tube) -> None:
    """Enable global s/sa/sl/sla/r/ru helpers."""
    global _global_io
    _global_io = io

def _io() -> tube:
    assert _global_io is not None, "Global io not set; call set_global_io(io)."
    return _global_io

def s(data):   return _io().send(data)
def sa(d, x):  return _io().sendafter(d, x)
def sl(x):     return _io().sendline(x)
def sla(d, x): return _io().sendlineafter(d, x)
def r(n=4096): return _io().recv(n)
def ru(d, drop=True): return _io().recvuntil(d, drop=drop)
def uu64(data: bytes) -> int: return u64(data.ljust(8, b"\x00"))


